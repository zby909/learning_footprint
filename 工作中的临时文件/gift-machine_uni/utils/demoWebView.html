<!--
 * @Description: 一个web页面可以调用原生插件的例子 配合pages/webview/pos.vue使用
 * @Author: zby
 * @Date: 2021-10-08 13:19:24
 * @LastEditors: zby
 * @Reference: 
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .con {
        width: 85%;
        margin: 80px auto;
      }
      .text {
        text-align: center;
      }
      #app {
        margin-top: 50px;
        animation: example 2s;
      }
      @keyframes example {
        0% {
          color: red;
        }
        25% {
          color: yellow;
        }
        50% {
          color: blue;
        }
        100% {
          color: green;
        }
      }
    </style>
  </head>
  <body>
    <div class="con">
      <div class="text">
        实验了<br />在uniapp当中挂载网页<br />并且使用了h5+的webview方法以及发布订阅开发思想<br />实现了可以正常调用原生插件的方法
        <div id="app">等待调用原生插件...</div>
      </div>
    </div>
    <!-- uni 的 SDK，必须引用。 -->
    <script type="text/javascript" src="//js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js"></script>
    <script>
      //实现一个简单的发布订阅 用以监听发送的原生api回调
      class EventEmitter {
        constructor() {
          this.events = {};
        }
        // 实现订阅
        on(type, callBack) {
          if (!this.events[type]) {
            this.events[type] = [callBack];
          } else {
            this.events[type].push(callBack);
          }
        }
        // 删除订阅
        off(type, callBack) {
          if (!this.events[type]) return;
          this.events[type] = this.events[type].filter(item => {
            return item !== callBack;
          });
        }
        // 只执行一次订阅事件
        once(type, callBack) {
          function onceFn(rest) {
            callBack(rest);
            this.off(type, onceFn);
          }
          this.on(type, onceFn);
        }
        // 触发事件
        emit(type, rest) {
          // console.log(rest);
          this.events[type] && this.events[type].forEach(fn => fn.call(this, rest));
        }
      }

      //创建发布订阅实例
      const event = new EventEmitter();

      //如创建了一个打印api接口 用以向App发送事件以执行打印 并监听回调（监听一次 执行过一次即卸载该回调）
      window.$print = (printData, res) => {
        //关键!!! 传入方法以及参数 在App接收用以调用相关App中的方法
        uni.postMessage({
          data: {
            toPrint: printData,
          },
        });
        //监听打印回调 有则带参数返回回调函数让调用者拿到失败或成功的状态
        event.once('listenPrinted', param => {
          res(param);
        });
      };

      //正文正文正文
      //正文正文正文
      //正文正文正文
      document.addEventListener('UniAppJSBridgeReady', () => {
        //模拟执行打印方法
        setTimeout(() => {
          window.$print('我是html传过来的数据', res => {
            //获取打印回调 成功/失败
            console.log(res);
            document.getElementById('app').innerText = res;
          });
        }, 2000);
        // uni.getEnv(function (res) {
        //   if (res.plus) {
        //     console.log("当前环境为【5+App】");
        //   } else if (res.miniprogram) {
        //     console.log("当前环境为【微信小程序】");
        //   }
        // });
      });
    </script>
  </body>
</html>
