<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Document</title>
</head>

<body>
	<script>
		// 快速排序（双指针）
		// 从数列中挑出一个元素，称为 “基准”（pivot）;
		// 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
		// 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
		// 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
		function quickSort(arr, left, right) {
			var len = arr.length,
				partitionIndex,
				left = typeof left != 'number' ? 0 : left,
				right = typeof right != 'number' ? len - 1 : right;

			if (left < right) {
				partitionIndex = partition(arr, left, right);
				quickSort(arr, left, partitionIndex - 1);
				quickSort(arr, partitionIndex + 1, right);
			}
			return arr;
		}

		function partition(arr, left, right) {     // 分区操作
			var pivot = left,                      // 设定基准值（pivot）
				index = pivot + 1;
			for (var i = index; i <= right; i++) {
				if (arr[i] < arr[pivot]) {
					swap(arr, i, index);
					index++;
				}
			}
			swap(arr, pivot, index - 1);
			return index - 1;
		}

		function swap(arr, i, j) {
			var temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}

		function paritition2(arr, low, high) {
			let pivot = arr[low];
			while (low < high) {
				while (low < high && arr[high] > pivot) {
					--high;
				}
				arr[low] = arr[high];
				while (low < high && arr[low] <= pivot) {
					++low;
				}
				arr[high] = arr[low];
			}
			arr[low] = pivot;
			return low;
		}

		function quickSort2(arr, low, high) {
			if (low < high) {
				let pivot = paritition2(arr, low, high);
				quickSort2(arr, low, pivot - 1);
				quickSort2(arr, pivot + 1, high);
			}
			return arr;
		}


		function swap(arr, i, j) {
			var temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}

		function paritition2(arr, low, high) {
			let pivot = arr[low];
			while (low < high) {
				while (low < high && arr[high] > pivot) {
					--high;
				}
				arr[low] = arr[high];
				while (low < high && arr[low] <= pivot) {
					++low;
				}
				arr[high] = arr[low];
			}
			arr[low] = pivot;
			return low;
		}

		function quickSort2(arr, low, high) {
			if (low < high) {
				let pivot = paritition2(arr, low, high);
				quickSort2(arr, low, pivot - 1);
				quickSort2(arr, pivot + 1, high);
			}
			return arr;
		}
		let myarr = [3, 6, 2, 4, 5, 1];
		bubbleSort(myarr);
	</script>
</body>

</html>